#! /usr/bin/env python

## system imports
import os
import sys
import getopt
import threading

## timer
from datetime import time
from datetime import date
from datetime import datetime
from TopAnalysis.TopUtils.tools.Timer import Timer

## configuration
import TopAnalysis.Configuration.processes as input
import TopAnalysis.TopUtils.tools.ConfigWrapper as cms

##-----------------------------------------------------------------------------------
## executive script for cmsRun, Version 1.1
## twiki: https://twiki.cern.ch/twiki/bin/view/CMS/ConfigRunner
class CfgRunner:
    ##
    ## configurables
    ##
    
    ## output logfile
    __outputLog       = ''
    ## error  logfile
    __outputErr       = ''
    ## file service output path
    __jobName         = ''
    ## file service output name    
    __outputName      = 'none'
    ## cfg file for cmsRun
    __config          = ''
    ## physics process/sample
    __process         = ''
    ## event of events to process
    __numberOfEvents  = 0
    ## event of events to skip    
    __numberOfSkips   = 0
    ## verbose mode
    __verbose         = False
    ## interactive mode
    __interactive     = False    

    ##
    ## internal variables
    ##

    ## version
    __version         = 'V00-00-02'
    ## time in seconds to wait
    __sleeptime       = 10
    ## internal farm parameters
    __farmParams      = ''
    ## user defined parameters
    __userParams      = ''
    ## for interactive mode
    __runs_           = ''
    ## for cmsRun execution
    __jobStarted      = False
    ## error handling
    __errorToken      = ['RootError', 'Exception', 'Root_Error']

##-----------------------------------------------------------------------------------    
##  Constructor
    def __init__(self):
        self.__cmsRunTimer  = {}
        self.__analysisTimer= {}

##-----------------------------------------------------------------------------------        
##  * start sequence
    def beginJob(self):
        versionLine = "*                                      "
        versionLine+= self.__version + " *"        
        print "**************************************************"
        print "* starting ConfigRunner...                       *"
        print "*                                                *"
        print "*                                                *"
        print "*                                                *"    
        print "*                                                *"
        print versionLine
        print "**************************************************"
        
##-----------------------------------------------------------------------------------        
##  * end sequence
##  * this may contain the execution of histPlotter or something similar                
    def endJob(self):
        print "**************************************************"
        print "* leaving ConfigRunner...                        *"
        print "*                                                *"
        print "*                                                *"
        print "*                                                *"    
        print "*                                                *"
        print "*                                      Good Bye! *"
        print "**************************************************"  

##-----------------------------------------------------------------------------------
##  * Parse command line options
##  * Do basic check whether the options make sense or not
##  * Depending on the options execute 'doAll' or 'doJob'
    def main(self):
        try:
            opts, args = getopt.getopt(sys.argv[1:],
                                       'hvic:p:s:e:o:d:f:u:',
                                       ['help','verbose','interactive','cfg=','proc=','skip=','evts=','out=','dir=','farm=','user=']
                                       )
        except getopt.error, msg:
            print msg
            print "for help use --help"
            sys.exit(2)

        for o, a in opts:
            ################################################
            ## get help
            ################################################                
            if o in ("-h", "--help"):
                self.__helpMsg()
                self.endJob()
                sys.exit(0)
            ################################################
            ## run verbose mode
            ################################################
            elif o in ("-v", "--verbose"):
                self.__verbose = True
            ################################################                
            ## run interactive batch mode
            ################################################                
            elif o in ("-i", "--interactive"):
                self.__interactive = True                
            ################################################                
            ## cmssw cfg file
            ################################################                
            elif o in ("-c", "--cfg"):
                self.__config = a
            ################################################                
            ## process of consideration
            ################################################                
            elif o in ("-p", "--proc"):
                self.__process = a
            ################################################                
            ## number of events to be processed
            ################################################                                
            elif o in ("-e", "--evts"):
                self.__numberOfEvents = int(a)
            ################################################                
            ## number of events to be skipped
            ################################################                                
            elif o in ("-s", "--skip"):
                self.__numberOfSkips  = int(a)                
            ################################################                
            ## define output file with process suffix
            ################################################
            elif o in ("-o", "--out"):
                if (not (a == '')):
                    self.__outputName = a
            ################################################
            ## define error file with sample suffix
            ################################################                
            elif o in ("-d", "--dir"):
                if (not a == ''):
                    self.__jobName = a
            ################################################                
            ## add farm parameters
            ################################################
            elif o in ("-f", "--farm"):
                if (not a == ''):
                    self.__farmParams = a
            ################################################                
            ## add user defined parameters
            ################################################
            elif o in ("-u", "--user"):
                if (not a == ''):
                    self.__userParams = a                    
            else:
                self.__errorMsg()
                print '* * argument(s) not recognized. See --help for usage'
                print "**************************************************"
        ## perform basic checks of the input
        self.__checkOptions()
        ## run and perform basic monitoring
        if(self.__interactive):
            self.__doAll()
        else:
            self.__doJob(self.__process)
            self.__waitingForEnd(self.__process)

##-----------------------------------------------------------------------------------
##  * print help message for the use of the ConfigRunner
    def __helpMsg(self):
        print "\n"
        print " Synopsis   : ConfigRunner [Option] --cfg '...' -p PROC -e EVTS -o OUTPUT  \n"
        print " Description: Script to allow replacement of cfg file parameters for cmsRun  "
        print "              via options; supported parameter replacements are:             "
        print "              * number of events         [-e],                               "
        print "              * number of skipped events [-s],                               "
        print "              * name of output file      [-o],                               "
        print "              * input source             [-p].                               "
        print "              The input source is steered via vector defines in the file:    "
        print "              './TopAnalysis/Configuration/python/processes.py'              "
        print "              Also user defined replacements are supported. The otuput [-o]  "
        print "              can be specified as \'none\'. When specifying the no of evts   "
        print "              to be processed with -1 all event will be processed          \n"
        print " Options    : -h | --help         [ ]   print this message                   "
        print "              -v | --verbose      [ ]   run in verbose mode                  "
        print "              -i | --interactive  [ ]   run in interactive mode              "
        print "              -c | --cfg  ...     [x]   specify config file                  "
        print "              -p | --proc ...     [x]   specify physics process              "
        print "              -s | --skip ...     [ ]   specify no of evts to be skipped     "
        print "              -e | --evts ...     [x]   specify no of evts to be processed   "        
        print "              -o | --out  ...     [x]   specify name of output file          "
        print "              -d | --dir  ...     [ ]   specify job directory                "
        print "              -f | --farm ...     [ ]   specify name of cfg\'s for farm use\n"
        print "              -u | --user ...     [ ]   specify user defined sequences     \n"        
        print " [ ] optional                                                                "
        print " [x] mandatory                                                               "
        print "\n"

##-----------------------------------------------------------------------------------            
##  * print head for simple error message            
    def __errorMsg(self):
        print "**************************************************"
        print "* Error:"

##-----------------------------------------------------------------------------------
##  * print head for simple warning message            
    def __warningMsg(self):
        print "**************************************************"
        print "* Warning:"
      
##-----------------------------------------------------------------------------------
##  * print message on screen
##  * used in __waitForFirst        
    def __printMsg(self, msg):
        print msg

##-----------------------------------------------------------------------------------
##  * basic check of input configuration
    def __checkOptions(self):
        ################################################
        ## number of events specified?
        ################################################        
        if (self.__numberOfEvents == 0):
            self.__errorMsg()
            print '* * no events to be processed. Choose --evts to specify'
            print "**************************************************"            
            sys.exit(0)
        ################################################
        ## physics process specified?
        ################################################            
        if (self.__process == ''):
            self.__errorMsg()
            print '* * no physics process specified. Choose --proc to specify'
            print "**************************************************"
            sys.exit(0)            
        ################################################
        ## configfile specified and existent?
        ################################################            
        if (self.__config == ''):
            self.__errorMsg()
            print '* * no config file specified. Choose --cfg to specify'
            print "**************************************************"            
        if (not os.path.exists(self.__config)):
            self.__errorMsg()
            print '* * config file doen\'t exist. Please check spelling'
            print "**************************************************"
            sys.exit(0)
        ################################################
        ## name of output file specified?
        ################################################            
        if (self.__outputName == 'none'):
            self.__warningMsg()
            print '* * no output name specified. Output name for file'
            print '* * service will not be altered when registered'
            print "**************************************************"
        ################################################
        ## output directory or jobname specified?
        ################################################            
        if (self.__jobName == ''):
            self.__jobName = 'job_'
            self.__jobName+= datetime.today().strftime("%Y%M%d-%H%M%S")
            self.__warningMsg()
            msg = '* * no output directory for job specified. Directory \n'
            msg+= '* * name was set to ' + self.__jobName 
            self.__printMsg(msg)
            print "**************************************************"
            
##-----------------------------------------------------------------------------------
##  * perform basic job monitoring
    def __monitorJob(self):
        err=False
        ################################################
        ## check for configuration file errors
        ################################################        
        if '---- Configuration BEGIN' in self.__readFromFile(self.__outputErr):
            self.__errorMsg()
            print '* * Configuration error occured & job aborted; please check .err file'
            print "**************************************************"
            err=True
        ################################################
        ## check for I/O errors
        ################################################        
        if '---- FileOpenError BEGIN' in self.__readFromFile(self.__outputErr):
            self.__errorMsg()
            print '* * I/O error occured & job aborted; please check .err file'
            print "**************************************************"
            err=True            
        ################################################            
        ## check if run started properly
        ################################################            
        if 'Root_Error' in self.__readFromFile(self.__outputErr):
            print '* * RootError occured & job aborted; please check .err file'
            print "**************************************************"
            err=True
        return err
    
##-----------------------------------------------------------------------------------
##  * read string from file (in read only)
##  * used in __waitForFirst                
    def __readFromFile(self, filename):
        file = open(filename, 'r')
        str = file.read()
        file.close()
        return str        

##-----------------------------------------------------------------------------------
##  * wait for the first event to be processed
##  * do some basic job monitoring
##  * estimate time elapsed to start cmsRun
##  * start runtime estimate            
    def __waitForFirst(self, process):
        printEvery = self.__sleeptime*1.3
        msg = "* * waiting for the 1st event for '" + str(process) + "' to be processed..." 
        printtimer = {}
        ## print msg up to 10 times
        for i in range(0,10):
            printtimer[i] = threading.Timer(printEvery*i, self.__printMsg, [msg])
            printtimer[i].start()
        ## wait until the files are created by cmsRun
        while(not os.path.exists(self.__outputErr)):
            Timer.sleep(1)
            ## if after 1min no file is created the script aborts
            if self.__cmsRunTimer[process].timePassed(os.times()) > 60:
                print "* * waited more then 1min for job to begin"
                print "* * aborting job..."
                os.sys.exit(0)
        ## waits until first event has been read
        while (self.__readFromFile(self.__outputErr) == ""):
            Timer.sleep(1)
        ## clear printtimer
        for i in printtimer:
            printtimer[i].cancel()
        ## make a first print out from logfile on screen
        ## in verbose mode
        if (self.__verbose):
            print self.__readFromFile(self.__outputErr)

        ## perform some basic job monitoring
        if (self.__monitorJob()):
            sys.exit(0)
        ## stop runstart timer
        self.__cmsRunTimer[process].stop()
        ## print time to screen to get cmsRun starting
        print '* * time elapsed to start cmsRun:', self.__cmsRunTimer[process].getMeasuredTime() 
        ## start analysis timer
        self.__analysisTimer[process].start()

##-----------------------------------------------------------------------------------
##  * execute cmsRun via shell console
##  * needs runtime environment to be set first            
    def __executeCMSrun(self, configfile):
        print '* * executing cmsRun...'
        if os.path.exists(configfile):
            print '* * >> cmsRun ' + configfile
            if os.path.exists(self.__outputLog):
                os.remove(self.__outputLog)
            if os.path.exists(self.__outputErr):
                os.remove(self.__outputErr)   
            ## needs runtime environment to be set first
            if (self.__interactive):
                os.system('cmsRun ' + configfile + " >" + self.__outputLog + " 2> " + self.__outputErr + " < /dev/null&")
            else:
                os.system('cmsRun ' + configfile + " >" + self.__outputLog + " 2> " + self.__outputErr + " < /dev/null" )                    
            self.__cmsRunTimer[self.__process].start()
            print '* * '
            self.__waitForFirst(self.__process)
            self.__jobStarted = True
        else:
            self.__errorMsg()
            print '* * requested configfile does not exist: this should never happen!'
            print "**************************************************"

##-----------------------------------------------------------------------------------
##  * create tmp config file
##  * modify std configurables            
##  * call executeCMSrun            
    def __doJob(self, proc):
        ## create job directory if doesn't exist yet
        ## and if __jobName != ''
        if (not os.path.exists(self.__jobName)):
            os.system('mkdir ' + self.__jobName)        
        ## create tmp config; choose a standard name
        ## if __farmParams was not specified via -f 
        tmp = "tmp_" + self.__jobName
        if (not self.__farmParams==''):
            tmp = self.__farmParams
        tmp+= "_cfg.py"
        process = cms.ConfigWrapper(self.__config, tmp, proc)
        ## modify events
        if (self.__numberOfEvents <= 0):
            self.__numberOfEvents = input.sizes[self.__process]
        process.modifyOption('events', self.__numberOfEvents)
        ## modify skips
        process.modifyOption('skips',  self.__numberOfSkips )
        ## modify source
        process.modifyOption('source', input.source[self.__process])
        ## modify output
        output = self.__jobName+'/'
        if (self.__outputName.lower() == 'none'):
            output+= self.__jobName
            output+= '_' + proc
            output+= '.root'
            process.modifyOption('output','none')            
        else:
            output+= self.__outputName
            output+= '_' + proc
            output+= '.root'
            process.modifyOption('output',output)
        ## setup outputLogs
        self.__outputLog = output.__str__().replace('.root', '.out')
        self.__outputErr = output.__str__().replace('.root', '.err')
        ## initilize timers
        self.__cmsRunTimer[proc] = Timer()
        self.__analysisTimer[proc] = Timer()

        ## uncomment for testing
        ## print "produced file: " + process.returnTempCfg(self.__jobName)
        ## start cmsRun
        self.__executeCMSrun(process.returnTempCfg(self.__jobName))

##-----------------------------------------------------------------------------------
##  * create a vector from a list of objects in a string separated by an arbitary
##    deliminator
##  * used in __doAll                
    def __vectorFromList(self, list, delim):
        myBuffer = []
        myVector = []
        if delim in list:
            myBuffer = list.split(delim)
        else:
            myBuffer = [list]
        
        for a in myBuffer:
            myVector.append(a)
            
        return myVector

##-----------------------------------------------------------------------------------
##  * wait for a single job to be finished
##  * perform basic job monitoring    
    def __waitingForEnd(self, process):
        err = False
        printEvery = self.__sleeptime
        if (self.__numberOfEvents == -1):
            ## every 30min when processing all events
            printEvery = self.__sleeptime*180
        else:
            ## every 100s for each 100 events else
            t = self.__numberOfEvents/100 - self.__numberOfEvents%100
            printEvery = self.__sleeptime*t
        
        ## print 'waiting up to 100 times
        printtimer = {}
        msg = "* * waiting for '" + str(process) + "' to end..."
        if printEvery > 0:
            for i in range(0,100):
                printtimer[i] = threading.Timer(printEvery*i, self.__printMsg, [msg])
                printtimer[i].start()

        ## while the run did not yet reach the run summary
        ## and wihle there did not yet occure any error
        while not 'Summary' in self.__readFromFile(self.__outputErr) and not err:
            ## perform basic monitoring
            err = self.__monitorJob()
            Timer.sleep(1)
            if((self.__analysisTimer[process].timePassed(os.times()) % printEvery) == 0):
                print '* * waiting for ', process, ' to end...'
        print '* * process ', process, ' finished'

        if printEvery > 0:
            ## clear printtimer
            for i in printtimer:
                printtimer[i].cancel()
        self.__analysisTimer[process].stop()
        print '* * time elapsed to exec  cmsRun:', self.__analysisTimer[process].getMeasuredTime()

##-----------------------------------------------------------------------------------
##  * start at least one job for each physics process
##  * do basic job monitoring for jobs in the background
##  * only called in interactive mode      
    def __doAll(self):
        ## get list of processes and create
        ## at least one run for each process
        self.__runs = self.__vectorFromList(self.__process, ';')
        ## for each 'process' in 'run'
        for i in self.__runs:
            self.__process = i
            ## check if process is defined
            if (self.__process in input.source.keys()):              
                self.__doJob(self.__process)
                if self.__jobStarted:
                    print ""
                    thread = threading.Thread(target=self.__waitingForEnd, args=(self.__process,))
                    thread.start()
                    self.__jobStarted = False
            elif self.__process == 'quit':
                os._exit(0)
            else:
                self.__errorMsg()
                print "* * not allowed process!"
                print "* * allowed processes are: ", cms.Config.allowedProcesses
                print "**************************************************"
                os._exit(0)
                
##-----------------------------------------------------------------------------------
if __name__ == '__main__':
    runner = CfgRunner()
    runner.beginJob()
    runner.main()
    runner.endJob()
